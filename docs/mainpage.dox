/**
 * @mainpage Nimble — Device Framework for Embedded Systems
 *
 * @section intro_sec Introduction
 * Nimble is a small, deterministic C++17 framework for building predictable,
 * safety-oriented embedded applications. It focuses on time-triggered, cyclic
 * execution of simple device components with explicit budgets and well-defined
 * lifecycle hooks. Nimble is suitable for bare-metal and freestanding environments
 * where dynamic allocation, exceptions and RTTI are undesirable or unavailable.
 *
 * @section goals_sec Goals
 * - Provide a compact, auditable execution model for embedded systems
 * - Keep runtime footprint minimal and predictable
 * - Make timing behaviour explicit with declared WCETs and static schedules
 * - Avoid hidden global state: all mutable runtime state lives in `nimble::ExecContext`
 * - Offer simple building blocks that are easy to reason about and verify
 *
 * @section features_sec Key Features
 * - Deterministic cyclic executive with major/minor frames
 * - Simple POD `Device` descriptors with lifecycle hooks (init/start/stop/fault)
 * - Compile-time schedule descriptions (`nimble::MinorFrameDef`, `nimble::ScheduleDef`)
 * - Per-device declared WCET for budget enforcement and overrun handling
 * - Multiple, swappable schedules and safe schedule switching at major-frame boundaries
 * - Pluggable overrun and catch-up policies (drop, skip, signal, reset)
 * - No dynamic memory, no exceptions, no RTTI — freestanding friendly
 * - Minimal dependencies; intended for resource-constrained targets
 *
 * @section architecture_sec Architecture Overview
 * Nimble is organized into a few focused layers:
 * - Core abstractions (`framework/include/core/`): `Device`, `Health`, `Time` types
 * - Schedule definitions (`framework/include/schedule/`): minor/major frame types
 * - Policies (`framework/include/policy/`): overrun/catch-up strategy enums
 * - Executive (`framework/include/executive/` & `framework/src/executive/`): the runtime driver
 *
 * @subsection arch_device Device Model
 * Each device is a POD descriptor describing the device's callbacks and timing:
 * - `init` — optional initialization executed once at startup
 * - `start` / `stop` — lifecycle transitions
 * - `update` — periodic execution invoked by the scheduler
 * - `on_fault` — fault handler invoked when a device signals an unrecoverable error
 * - `period_ms` and `wcet_us` — timing and budget metadata used by schedulers
 *
 * @subsection arch_schedule Schedule Model
 * Schedules are static data structures composed of minor frames. Each minor frame
 * lists device indices executed within that frame and a duration in microseconds.
 * The runtime cycles through a major frame composed of minor frames, producing a
 * predictable, repeating behavior.
 *
 * @subsection arch_executor Executor Behavior
 * The cyclic executor implementation drives execution from a caller-provided
 * monotonic time source. Key responsibilities:
 * - Maintain `nimble::ExecContext` with all runtime state and pointers to buffers
 * - Determine when a minor frame should start and invoke listed device `update`
 * - Track execution times and enforce per-frame budgets using declared WCET
 * - Update `nimble::Health` counters and record overruns
 * - Invoke policies on overrun/catch-up decisions
 *
 * @section api_sec Public API Summary
 * - `nimble::cyclic_init(ExecContext*, const Device*, size_t, const ScheduleDef*, size_t, size_t, Health*, DeviceState*, TimeSourceFn, OverrunPolicy)` — initialize runtime
 * - `nimble::cyclic_poll(ExecContext*)` — drive executor using the context time source
 * - `nimble::cyclic_tick_us(ExecContext*, uint64_t)` — advance executor with explicit time value
 * - Types: `nimble::Device`, `nimble::ExecContext`, `nimble::Health`, `nimble::MinorFrameDef`, `nimble::ScheduleDef`
 *
 * @section usage_sec Quick Start (example)
 * @code{.cpp}
 * #include "framework/include/core/device.h"
 * #include "framework/include/schedule/schedule_defs.h"
 * #include "framework/include/executive/cyclic_executor.h"
 *
 * void sensor_init(nimble::Device* d) { /* setup */ }
 * void sensor_update(nimble::Device* d) { /* read sensor */ }
 *
 * static nimble::Device devices[] = {
 *   { sensor_init, nullptr, sensor_update, nullptr, 1000, 500 }
 * };
 * static const uint16_t minor0_devs[] = { 0 };
 * static const nimble::MinorFrameDef minors[] = { { minor0_devs, 1, 100000 } }; // 100ms
 * static const nimble::ScheduleDef schedules[] = { { minors, 1 } };
 *
 * static nimble::Health health[1];
 * static nimble::DeviceState states[1];
 * static nimble::ExecContext ctx;
 *
 * nimble::cyclic_init(&ctx, devices, 1, schedules, 1, 0,
 *                    health, states, my_time_source,
 *                    nimble::OverrunPolicy::DropTask);
 *
 * // main loop
 * while (true) {
 *   nimble::cyclic_poll(&ctx);
 * }
 * @endcode
 *
 * @section integration_sec Integration & Build
 * - Include headers from `framework/include/` and link `framework/src/` object files
 * - Nimble is intentionally header-centric for the public API; implementation
 *   lives in the `executive` source module and can be compiled into a static
 *   library for your target.
 * - Recommended compiler flags: `-std=c++17 -O2 -fno-exceptions -fno-rtti`
 *
 * @section constraints_sec Constraints & Design Notes
 * - No dynamic allocations: all runtime buffers are provided by the caller
 * - Minimal STL usage to reduce footprint and improve analyzability
 * - Single-threaded by design; integrating with an RTOS requires adapting
 *   the time source and calling model
 *
 * @section safety_sec Safety & Verification
 * - Explicit WCET annotations enable simple schedulability checks
 * - Health counters and per-device overrun tracking assist debugging
 * - The small code surface and POD data structures make formal review simpler
 *
 * @section contributing_sec Contributing
 * Contributions welcome: open PRs, file issues, and follow the coding and
 * determinism principles. See repository README for contribution guidelines.
 *
 * @section contact_sec Contact
 * - Repository: https://github.com/yourusername/nimble
 * - For questions open an issue or contact the maintainers listed in the repo.
 */
